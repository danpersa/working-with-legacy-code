<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Working With Legacy Code</h1>
					<small>based on</small>
					<h3>
						<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052>">
							Working Effectively with Legacy Code - By Michael Feathers
						</a>
					</h3>

					<p>
						<small>Contributors
							<ul>
								<li>
									<a href="https://github.com/danpersa">Dan Persa</a> / <a href="http://twitter.com/danpersa">@danpersa</a>
								</li>
								<li>
									<a href="#">Add your name with your first pull request</a> / <a href="#">@twitter</a>
								</li>
							</ul>
						</small>
					</p>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Introduction
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Legacy Code

							Systems rot over time

							Blame the customer???

							### FLASH!! REQUIREMENTS CHANGE!!

							Blame your design

							Notes:
							The nice system we build today, starts to rot over time like
							a piece of bad meat.

							Blaming the customer is not an option as FLASH: Requirements
							change.

							Designs that can't tolerate changing requirements are poor.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							> &ldquo;Nearly every system ever produced suffers from rot.&rdquo;

							<p align="right">*Robert C. Martin*</p>


							Notes:
							It seems that nearly every system ever produced suffers from rot.

							We even have come up with a name for rotten programs:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Legacy Code
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Prevention Is Imperfect

							Notes:
							There are ways to prevent the code from rotting, but even
							the most disciplined team messes up form time to time.

							It's not enough to try to prevent the rot, we need to be
							able to reverse it.

							After reading Michael Feather's book we will be able to turn
							systems that gradually degrade into system that gradually
							improve
						</script>
					</section>
				</section>
				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						# What is Legacy Code
						## (TODO)
					</script>
				</section>
				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Changing Software
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							1. Add a feature
							2. Fix a bug
							3. Improve the design
							4. Optimise resource usage

							Notes:
							There are four reasons to change the software.

							Behavior is the most important thing about software

							Improve the design: Alter the software's structure but keep
							the behavior. Refactoring means structured modifications
							supported by tests.

							Higher risk, that's why the tests are so important

							Optimise resource usage means keeping the functionality but
							change some resource (memory, time)
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## The Challange

```
_______________________________________________________________________
|                                                               |     |
|                                                               |     |
|_______________________________________________________________|_____|
                                 |                                 |
                                 |                                 |
                         Existing behavior                 New behavior
```
							Notes:
							It seems impossible to add behavior without change the
							existing one

							We have to figure out how to preserve the existing behavior

							The problem is that we don't know how much behavior is at risk
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							1. What changes do we have to make?
							2. How do we know that we've done them correctly?
							3. How will we know that we haven't broken anything?

							Notes:
							To mitigate risk, we have to ask three questions: (see slide)

							In good we are confident about the change we make. We learn
							the system once and then we know where to do the changes.

							In poor code bases we hesitate.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Avoiding Change??

							Notes:
							Avoiding change has consequences:

							- people who don't do changes get rusty at it
							- when you do it often, it becomes routine
							- the fear of change will make the system worse every day
						</script>
					</section>
				</section>
				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Working with Feedback
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Edit & Prey <small>industry standard</small>
							## Cover and Modify

							Notes:
							Cover you code with tests. The tests will act as a safety net
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							Get feedback fast with unit tests:

							- Refactor
							- Run the tests
							- Write more tests

							The next developer says thanks!

							Notes:
							The next developer might be you!!!
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Why write Unit Testing?

							- Error localization
							- Execution time
							- Coverage

							Notes:
							Why write unit tests instead of getting feedback from a QA team?
							Unit testing is mainstream nowadays! I hope there are not codebases
							without unit tests anymore

							- Unit tests help with error localization.
							- Get feedback faster
							- QA can't cover all
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Good Unit Tests

							1. Should run fast
							2. Should help us localize the problem

							Notes:
							Here are the qualities of good unit tests:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Bad Unit Tests
							1. Talks to a database
							2. Communicates across a network
							3. It touches the file system
							4. Have to do special things to your environment

							Notes:
							Here are the qualities of bad unit tests:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## How to Approach Legacy Code?

							Cover the code with tests before changing it

							Notes:
							How to approach legacy code? One tip would be to cover the code
							with tests before changing it

							But is this easy?
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# The Legacy Code Dilema
							## When we change code, we should have tests in place. To put tests in place, we often have to change code.

							Notes:
							How do we solve this??
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## The Legacy Code Change Algorithm

							1. Identify change points
							2. Find tests points
							3. Break dependencies
							4. Write tests
							5. Make changes and refactor

							Notes:
							1. The places where you need to make changes depend on the architecture
							2. In legacy code this is sometimes hard
							3. Do initial refactorings in order to be able to write tests
							   Be conservative about the initial refactorings
							4. Use baby steps and TDD
						</script>
					</section>
				</section>
				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Sensing and Separation
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							Get tests in place

							Two reasons to break dependencies

							* Sensing - *sense* when we can't access values our code computes
							* Separation - *separate* when we can't get a piece of code into a test harness to run

							Notes:

							When we want to get tests in place, there are two reasons to
							break dependencies: sensing and separation
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Faking Collaborators

							* In OO languages FC are implemented as simple classes
							* In non-OO languages we can define an alternate function
							* Use Mocking Frameworks
							* Mock objects perform assertions internally

							Notes:
							There are lots of techniques to separate software, but one primary tool:
							Fake collaborators

							Usually we use a mocking framework like Mockito for Java
						</script>
					</section>
				</section>
				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# The Seam Model
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							* Legacy code is poorly suited to testing
							* We should design our new code for testing
							* But how to deal with the old one?
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							> &ldquo;A seam is a place where you can alter the behavior in your program
							> without editing that place.&rdquo;

							<p align="right">*Michael Feathers*</p>
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							> &ldquo;Every seam has an enabling point, a place where you can make the decision to use
							> one behavior or another.&rdquo;

							<p align="right">*Michael Feathers*</p>
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Preprocessing Seams
							## Link Seams
							## Object Seams

							Notes:
							* Used in C, C++, I hope nowhere else
							* The example of the book is hacking the java classpath
							we don't think this is a good practice, but when dealing
							with legacy code, anything is possible
							* Spring Profiles for tests is a good example for an Object Seam
						</script>
					</section>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## I Don't Have Much Time and I Have to Change It
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Break Dependencies
							# Write Tests

							Notes:
							First step when dealing with legacy code is breaking dependencies,
							and writing tests
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Time consuming
							## Does this worth it??

							Notes:
							But this is time consuming! Does this worth it?
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							> &ldquo;Code is your house and you have to live in it!&rdquo;

							<p align="right">*Michael Feathers*</p>

							Notes:
							Remember, code is your house and you have to live in it!

							Either write tests as you make your changes, or live with the fact
							that it is going to be tougher over time.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Can you do the changes in your code by writing fresh code?

							Notes:
							If you really can't afford to break dependencies and get tests in
							place, look at the changes that you need to make and ask yourself

							Can you make them by writing fresh code??

							We'll talk about some techniques to consider:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Sprout Method

							Do your changes as a new method and write tests for it
							Notes:

						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## TODO: Sprout Method Example

							Notes:

						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Sprout Method Steps

							1. Identify where you need to make your code changes
							2. If the change can be formulated as a single sequence
							   of statements in one place in a method, write down a
							   call for a new method that will do the work involved
							   and then comment it out
							3. Determine what local variables you need from the source method,
							   and make them arguments to the call
							4. Determine whether the sprouted method will need to return values
							   to source method. If so, change the call so that its return
							   value is assigned to a variable
							5. Develop the sprout method using test-driven development
							6. Remove the comment in the source method to enable the call

							Notes:

						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Sprout Method Advantages

							You are clearly separating new code from old code

							Notes:

							Even if you can't get the old code under test immediately, you can
							at least see your changes separately and have a clean interface
							between the new code and the old code. You see all of the variables
							affected, and this can make it easier to determine whether the code
							is rightin context
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Sprout Method Disadvantages

							You are saying that you are giving up on the source method
							and its class for the moment

							Notes:

							Giving up on a method or a class is the practical choice sometimes,
							but it still is kind of sad. It leaves your code in limbo.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Sprout Class

							You are saying that you are giving up on the source method
                            and its class for the moment

							Notes:

							Sometimes, Sprout Method is not powerful enough. Sprout Class
							to the rescue! It's the same idea as for the Sprout Method,
							but you create a new class and give the local variables as
							parameters to the new classe's constructor
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Wrapper Method

							Wrap method is a great way to introduce seams while adding new
							features.

							Notes:
							Another technique for doing changes to the code by writing new code
							is Wrapper Method
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## TODO: Wrapper Method Example
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Wrapper Method Steps
							1. Identify a method you need to change.
							2. If the change can be formulated as a single sequence of
							   statements in one place, develop a new method for it
							   using test-driven development (88).
							3. Create another method that calls the new method and the old method.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Wrapper Method Advantages

							* Getting new, tested functionality into the legacy app
							* It explicitly makes the new functionality independent of
							  existing functionality
							* Does not increase the size of the existing methods
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Wrapper Method Disadvantages

							It can lead to poor names
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Wrapper Class

							Decorator Pattern

							Notes:
							The class level companion to Wrap Method is Wrap Class. It uses
							pretty much the same concept so we won't get into details.
							Feel free to consult the book :)
						</script>
					</section>
				</section>
                
                <section>
                    <section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## It takes Forever to Make a Change
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Reasons why it may take a long time to do a change

							* Understanding
							* Lag time
							* Breaking those dependencies
                            
							Notes:
						
							* Understand all of the effects of a change on code
							* Time between a code change and getting feedback of that change. In the context, build time. 
                            Dependencies make the build slower
							* Breaking dependencies takes time
							
						</script>
					</section>
                    <section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Understanding
							<img width="70%" data-src="images/understanding_time.png" alt="Understanding time vs code base">

							Notes:
							The larger the code base is, the more time it takes to understant it, more or less exponentially.
							
						</script>
					</section>
                    <section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							### Well maintained vs Legacy system
							<table>
							<thead>
							<tr>
								<th></th>
								<th></th>
								<th></th>
							    <th></th>
							</tr>
							</thead>
							<tbody>
							<tr>
								<td>To figure out how to make a change</td>
								<td>might take a while</td>
								<td></td>
							    <td>would take a long time</td>
							<tr>
							<tr>
								<td>Once you figure out</td>
								<td>the change is easy</td>
								<td></td>
							    <td>change is difficult</td>
							<tr>
							<tr>
								<td>Confidence with the change</td>
								<td>high</td>
								<td></td>
							    <td>hope for the best</td>
							<tr>
							</tbody>
							</table>

							Notes:
							Changes in legacy code are done with a feeling like only small portion of code is comprehended, 
                            there is a hope for the best attitude.
						</script>
					</section>
                    <section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Lag time

							The amount of time between a change and getting feedback about the change

							Notes:
							Changes done -> re-building and running tests (to see changes) takes too long, focus is lost.
							Main obstacle in work with compiled languages is dependency, need to compile something, in order to 
                            compile what we actually want to.
						</script>
					</section>
                    <section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Breaking dependencies

							Dependencies make it slower to recompile the classes of interest

							Notes:

							
						</script>
					</section>
                    <section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Build dependencies

							In OOP system, to build cluster of classes quickly:

							1. Find dependencies
							2. Extract interfaces for the classes

							Notes:
							Makes overall build more complex, but average time for build can decrease dramatically. Once the 
                            cluster of classes is put under test, it gives an option to change the physical structure, 
                            e.g. repackage interfaces into separate package or library.
						</script>
					</section>
                    <section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Example
							## TODO;
                        </script>
					</section>
                    <section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## The dependency invasion principle

							>For a class that depends on interface, dependency is minor and unobstrusive.  
                            It makes the build between changes quicker.

							Notes:
							Better to depend on interface or abstract class. Makes rebuilding faster, 
                            because dependencies need not to be recompiled.
                        </script>
					</section>
                </section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
