<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>reveal.js - The HTML Presentation Framework</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/beige.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Working With Legacy Code</h1>
					<small>based on</small>
					<h3>
						<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052>">
							Working Effectively with Legacy Code - By Michael Feathers
						</a>
					</h3>

					<p>
						<small>Contributors
							<ul>
								<li>
									<a href="https://github.com/danpersa">Dan Persa</a> / <a href="http://twitter.com/danpersa">@danpersa</a>
								</li>
								<li>
									<a href="#">Add your name with your first pull request</a> / <a href="#">@twitter</a>
								</li>
							</ul>
						</small>
					</p>
				</section>

				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Introduction
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Legacy Code

							Systems rot over time

							Blame the customer???

							### FLASH!! REQUIREMENTS CHANGE!!

							Blame your design

							Notes:
							The nice system we build today, starts to rot over time like
							a piece of bad meat.

							Blaming the customer is not an option as FLASH: Requirements
							change.

							Designs that can't tolerate changing requirements are poor.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							> &ldquo;Nearly every system ever produced suffers from rot.&rdquo;

							<p align="right">*Robert C. Martin*</p>


							Notes:
							It seems that nearly every system ever produced suffers from rot.

							We even have come up with a name for rotten programs:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Legacy Code
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Prevention Is Imperfect

							Notes:
							There are ways to prevent the code from rotting, but even
							the most disciplined team messes up form time to time.

							It's not enough to try to prevent the rot, we need to be
							able to reverse it.

							After reading Michael Feather's book we will be able to turn
							systems that gradually degrade into system that gradually
							improve
						</script>
					</section>
				</section>
				<section data-markdown data-separator-notes="^Notes:">
					<script type="text/template">
						# What is Legacy Code
						## (TODO)
					</script>
				</section>
				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Changing Software
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							1. Add a feature
							2. Fix a bug
							3. Improve the design
							4. Optimise resource usage

							Notes:
							There are four reasons to change the software.

							Behavior is the most important thing about software

							Improve the design: Alter the software's structure but keep
							the behavior. Refactoring means structured modifications
							supported by tests.

							Higher risk, that's why the tests are so important

							Optimise resource usage means keeping the functionality but
							change some resource (memory, time)
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## The Challange

```
_______________________________________________________________________
|                                                               |     |
|                                                               |     |
|_______________________________________________________________|_____|
                                 |                                 |
                                 |                                 |
                         Existing behavior                 New behavior
```
							Notes:
							It seems impossible to add behavior without change the
							existing one

							We have to figure out how to preserve the existing behavior

							The problem is that we don't know how much behavior is at risk
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							1. What changes do we have to make?
							2. How do we know that we've done them correctly?
							3. How will we know that we haven't broken anything?

							Notes:
							To mitigate risk, we have to ask three questions: (see slide)

							In good we are confident about the change we make. We learn
							the system once and then we know where to do the changes.

							In poor code bases we hesitate.
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Avoiding Change??

							Notes:
							Avoiding change has consequences:

							- people who don't do changes get rusty at it
							- when you do it often, it becomes routine
							- the fear of change will make the system worse every day
						</script>
					</section>
				</section>
				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Working with Feedback
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Edit & Prey <small>industry standard</small>
							## Cover and Modify

							Notes:
							Cover you code with tests. The tests will act as a safety net
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							Get feedback fast with unit tests:

							- Refactor
							- Run the tests
							- Write more tests

							The next developer says thanks!

							Notes:
							The next developer might be you!!!
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Why write Unit Testing?

							- Error localization
							- Execution time
							- Coverage

							Notes:
							Why write unit tests instead of getting feedback from a QA team?
							Unit testing is mainstream nowadays! I hope there are not codebases
							without unit tests anymore

							- Unit tests help with error localization.
							- Get feedback faster
							- QA can't cover all
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Good Unit Tests

							1. Should run fast
							2. Should help us localize the problem

							Notes:
							Here are the qualities of good unit tests:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Bad Unit Tests
							1. Talks to a database
							2. Communicates across a network
							3. It touches the file system
							4. Have to do special things to your environment

							Notes:
							Here are the qualities of bad unit tests:
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## How to Approach Legacy Code?

							Cover the code with tests before changing it

							Notes:
							How to approach legacy code? One tip would be to cover the code
							with tests before changing it

							But is this easy?
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# The Legacy Code Dilema
							## When we change code, we should have tests in place. To put tests in place, we often have to change code.

							Notes:
							How do we solve this??
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## The Legacy Code Change Algorithm

							1. Identify change points
							2. Find tests points
							3. Break dependencies
							4. Write tests
							5. Make changes and refactor

							Notes:
							1. The places where you need to make changes depend on the architecture
							2. In legacy code this is sometimes hard
							3. Do initial refactorings in order to be able to write tests
							   Be conservative about the initial refactorings
							4. Use baby steps and TDD
						</script>
					</section>
				</section>
				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# Sensing and Separation
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							Get tests in place

							Two reasons to break dependencies

							* Sensing - *sense* when we can't access values our code computes
							* Separation - *separate* when we can't get a piece of code into a test harness to run

							Notes:

							When we want to get tests in place, there are two reasons to
							break dependencies: sensing and separation
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Faking Collaborators

							* In OO languages FC are implemented as simple classes
							* In non-OO languages we can define an alternate function
							* Use Mocking Frameworks
							* Mock objects perform assertions internally

							Notes:
							There are lots of techniques to separate software, but one primary tool:
							Fake collaborators

							Usually we use a mocking framework like Mockito for Java
						</script>
					</section>
				</section>
				<section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							# The Seam Model
						</script>




					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							* Legacy code is poorly suited to testing
							* We should design our new code for testing
							* But how to deal with the old one?
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							> &ldquo;A seam is a place where you can alter the behavior in your program
							> without editing that place.&rdquo;

							<p align="right">*Michael Feathers*</p>
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							> &ldquo;Every seam has an enabling point, a place where you can make the decision to use
							> one behavior or another.&rdquo;

							<p align="right">*Michael Feathers*</p>
						</script>
					</section>
					<section data-markdown data-separator-notes="^Notes:">
						<script type="text/template">
							## Preprocessing Seams
							## Link Seams
							## Object Seams

							Notes:
							* Used in C, C++, I hope nowhere else
							* The example of the book is hacking the java classpath
							we don't think this is a good practice, but when dealing
							with legacy code, anything is possible
							* Spring Profiles for tests is a good example for an Object Seam

						</script>
					</section>
				</section>
			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
